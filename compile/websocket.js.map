{
"version":3,
"file":"compile/websocket.js",
"lineCount":88,
"mappings":"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",
"sources":["node_modules/erte/src/index.js","node_modules/crypto/index.js","src/lib.js","src/depack.js","src/index.js"],
"sourcesContent":["import Diff from './diff'\n\nconst colors = {\n  'black': 30,\n  'red': 31,\n  'green': 32,\n  'yellow': 33,\n  'blue': 34,\n  'magenta': 35,\n  'cyan': 36,\n  'white': 37,\n  'grey': 90,\n}\n\nconst backgroundColors = {\n  'black': 40,\n  'red': 41,\n  'green': 42,\n  'yellow': 43,\n  'blue': 44,\n  'magenta': 45,\n  'cyan': 46,\n  'white': 47,\n}\n\n/**\n * Color the foreground.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function c(string, color) {\n  const cc = colors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Color the background.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function b(string, color) {\n  const cc = backgroundColors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Compares two strings and outputs a coloured version where strings don't match.\n * @param {string} source A string to compare.\n * @param {string} target Target string to compare with.\n * @returns {string} A string which uses shell-codes to highligh differences.\n */\nexport default function erte(source, target) {\n  const diff = new Diff()\n  const d = diff.diff(source, target)\n  const m = d.map(({ added, removed, value }) => {\n    let p\n    const s = value.split(' ')\n    if (added) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'green')).join(b(' ', 'green'))\n    } else if (removed) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'red')).join(b(' ', 'red'))\n    } else {\n      p = c(value, 'grey')\n    }\n    return p\n  })\n  const s = m.join('')\n  return s\n}\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_erte.Color} Color The color to apply.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {('black'|'red'|'green'|'yellow'|'blue'|'magenta'|'cyan'|'white'|'grey')} _erte.Color The color to apply.\n */\n","export default _crypto\nexport const {\n  Certificate,\n  Cipher,\n  Credentials,\n  DEFAULT_ENCODING,\n  Decipher,\n  DiffieHellman,\n  ECDH,\n  Hash,\n  Hmac,\n  Verify,\n  createCipher,\n  createCipheriv,\n  createCredentials,\n  createDecipher,\n  createDecipheriv,\n  createDiffieHellman,\n  createECDH,\n  createHash,\n  createHmac,\n  createSign,\n  createVerify,\n  getCiphers,\n  getCurves,\n  getDiffieHellman,\n  getHashes,\n  pbkdf2,\n  pbkdf2Sync,\n  privateDecrypt,\n  privateEncrypt,\n  pseudoRandomBytes,\n  publicDecrypt,\n  publicEncrypt,\n  randomBytes,\n  randomFill,\n  randomFillSync,\n  timingSafeEqual,\n} = _crypto","import { createHash } from 'crypto'\n\n// copyright https://medium.com/hackernoon/implementing-a-websocket-server-with-node-js-d9b78ec5ffa8\n\nexport function constructReply(data) {\n  // Convert the data to JSON and copy it into a buffer\n  const json = JSON.stringify(data)\n  const jsonByteLength = Buffer.byteLength(json)\n  // Note: we're not supporting > 65535 byte payloads at this stage\n  const lengthByteCount = jsonByteLength < 126 ? 0 : 2\n  const payloadLength = lengthByteCount === 0 ? jsonByteLength : 126\n  const buffer = Buffer.alloc(2 + lengthByteCount + jsonByteLength)\n  // Write out the first byte, using opcode `1` to indicate that the message\n  // payload contains text data\n  buffer.writeUInt8(0b10000001, 0)\n  buffer.writeUInt8(payloadLength, 1)\n  // Write the length of the JSON payload to the second byte\n  let payloadOffset = 2\n  if (lengthByteCount > 0) {\n    buffer.writeUInt16BE(jsonByteLength, 2)\n    payloadOffset += lengthByteCount\n  } // Write the JSON data to the data buffer\n  buffer.write(json, payloadOffset)\n  return buffer\n}\n\nexport function parseMessage(buffer) {\n  const firstByte = buffer.readUInt8(0)\n  const isFinalFrame = Boolean((firstByte >>> 7) & 0x1)\n  const [reserved1, reserved2, reserved3] = [ Boolean((firstByte >>> 6) & 0x1), Boolean((firstByte >>> 5) & 0x1), Boolean((firstByte >>> 4) & 0x1) ]\n  const opCode = firstByte & 0xF\n  // We can return null to signify that this is a connection termination frame\n  if (opCode === 0x8)\n    return null\n  // We only care about text frames from this point onward\n  if (opCode !== 0x1)\n    return\n  const secondByte = buffer.readUInt8(1)\n  const isMasked = Boolean((secondByte >>> 7) & 0x1)\n  // Keep track of our current position as we advance through the buffer\n  let currentOffset = 2; let payloadLength = secondByte & 0x7F\n  if (payloadLength > 125) {\n    if (payloadLength === 126) {\n      payloadLength = buffer.readUInt16BE(currentOffset)\n      currentOffset += 2\n    } else {\n      // 127\n      // If this has a value, the frame size is ridiculously huge!\n      const leftPart = buffer.readUInt32BE(currentOffset)\n      const rightPart = buffer.readUInt32BE(currentOffset += 4)\n      throw new Error('Large payloads not currently implemented')\n    }\n  }\n  let maskingKey\n  if (isMasked) {\n    maskingKey = buffer.readUInt32BE(currentOffset)\n    currentOffset += 4\n  }\n  // Allocate somewhere to store the final message data\n  const data = Buffer.alloc(payloadLength)\n  // Only unmask the data if the masking bit was set to 1\n  if (isMasked) {\n    // Loop through the source buffer one byte at a time, keeping track of which\n    // byte in the masking key to use in the next XOR calculation\n    for (let i = 0, j = 0; i < payloadLength; ++i, j = i % 4) {\n    // Extract the correct byte mask from the masking key\n      const shift = j == 3 ? 0 : (3 - j) << 3\n      const mask = (shift == 0 ? maskingKey : (maskingKey >>> shift)) & 0xFF\n      // Read a byte from the source buffer\n      const source = buffer.readUInt8(currentOffset++) // XOR the source byte and write the result to the data buffer\n      data.writeUInt8(mask ^ source, i) }\n  } else {\n    // Not masked - we can just read the data as-is\n    buffer.copy(data, 0, currentOffset++)\n  }\n  return `${data}`\n}\n\n/**\n * Creates an accept value for websocket.\n * @param {string} key The client key.\n */\nexport function generateAcceptValue(key) {\n  return createHash('sha1')\n    .update(`${key}258EAFA5-E914-47DA-95CA-C5AB0DC85B11`, 'binary')\n    .digest('base64')\n}","import '../types/externs'\nimport websocket from './'\n\nmodule.exports = {\n  '_websocket': websocket,\n}","import { b } from 'erte'\nimport { constructReply, parseMessage, generateAcceptValue } from './lib'\n\n/**\n * @type {_idio.websocket}\n */\nfunction websocket(server, config = {}) {\n  const {\n    // eslint-disable-next-line no-unused-vars\n    onMessage = (cid, m) => {},\n    // eslint-disable-next-line no-unused-vars\n    onConnect = (cid) => {},\n    log = true,\n  } = config\n  const clients = {}\n  /**\n   * @param {!http.IncomingMessage} req\n   * @param {!net.Socket} socket\n   */\n  function listener(req, socket) {\n    /**\n     * @suppress {checkTypes}\n     */\n    const UPGRADE = req.headers['upgrade']\n    if (UPGRADE != 'websocket') {\n      socket.end('HTTP/1.1 400 Bad Request')\n      return\n    }\n    /**\n     * @suppress {checkTypes}\n     */\n    const PROTO = req.headers['sec-websocket-protocol']\n    /**\n     * @suppress {checkTypes}\n     */\n    const KEY = req.headers['sec-websocket-key']\n    const hash = generateAcceptValue(KEY)\n    const responseHeaders = [\n      'HTTP/1.1 101 Web Socket Protocol Handshake',\n      'Upgrade: WebSocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${hash}`,\n    ]\n    // Read the subprotocol from the client request headers:\n    const protocols = !PROTO ? [] : PROTO.split(',').map(s => s.trim())\n    if (protocols.includes('json')) {\n      responseHeaders.push('Sec-WebSocket-Protocol: json')\n    }\n    socket.write(responseHeaders.join('\\r\\n') + '\\r\\n\\r\\n')\n    log && console.log(b('Client connected.', 'green'))\n    socket.on('data', buffer => {\n      const message = parseMessage(buffer)\n      if (message) {\n        onMessage(KEY, message)\n      } else if (message === null) {\n        delete clients[KEY]\n        log && console.log(b('Client disconnected.', 'red'))\n      }\n    })\n    /**\n     * @type {_idio.sendMessage}\n     */\n    const sendMessage = (event, message) => {\n      socket.write(constructReply({ event, message }))\n    }\n    clients[KEY] = sendMessage\n    onConnect(KEY)\n  }\n  server.on('upgrade', listener)\n  return clients\n}\n\nexport default websocket\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').websocket} _idio.websocket\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').sendMessage} _idio.sendMessage\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('http').IncomingMessage} http.IncomingMessage\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('net').Socket} net.Socket\n */"],
"names":["backgroundColors","b","string","color","cc","createHash","_crypto","constructReply","data","json","JSON","stringify","jsonByteLength","Buffer","byteLength","lengthByteCount","payloadLength","buffer","alloc","writeUInt8","payloadOffset","writeUInt16BE","write","generateAcceptValue","key","update","digest","module","exports","websocket","server","config","onMessage","onConnect","log","clients","on","listener","req","socket","headers","UPGRADE","end","PROTO","KEY","responseHeaders","hash","includes","protocols","split","map","s","trim","push","join","console","opCode","readUInt8","firstByte","secondByte","isMasked","currentOffset","readUInt16BE","readUInt32BE","Error","maskingKey","i","j","shift","mask","source","copy","message","event","sendMessage"]
}
